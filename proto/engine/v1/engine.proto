syntax = "proto3";
package engine.v1;

// Minimal EngineWorker API for a vLLM-like engine
service EngineWorker {
  rpc Health(HealthRequest) returns (HealthResponse);
  rpc CreateSession(CreateSessionRequest) returns (CreateSessionResponse);
  rpc StartSequence(StartSequenceRequest) returns (StartSequenceResponse);
  rpc Prefill(PrefillRequest) returns (PrefillResponse);
  rpc Decode(DecodeRequest) returns (DecodeResponse);
  // Batch variants for simple micro-batching
  rpc BatchPrefill(BatchPrefillRequest) returns (BatchPrefillResponse);
  rpc BatchDecode(BatchDecodeRequest) returns (BatchDecodeResponse);
  rpc ReleaseSequence(ReleaseSequenceRequest) returns (ReleaseSequenceResponse);
}

message HealthRequest {}
message HealthResponse {
  bool ok = 1;
  string worker_version = 2;
}

message CreateSessionRequest {
  string model_id = 1;
  string dtype = 2;    // e.g., bf16, fp16
  string device = 3;   // e.g., cuda:0, cpu
  repeated string adapters = 4; // LoRA or other adapters
}
message CreateSessionResponse {
  bool ok = 1;
  string session_id = 2;
  string error = 3;
}

message StartSequenceRequest {
  string session_id = 1;
}
message StartSequenceResponse {
  bool ok = 1;
  string seq_id = 2;
  string error = 3;
}

message PrefillRequest {
  string session_id = 1;
  string seq_id = 2;
  repeated uint32 tokens = 3; // toy token ids in this scaffold
  uint32 start_pos = 4;
  bool return_last_logits = 5;
}
message PrefillResponse {
  bool ok = 1;
  uint32 consumed = 2;
  repeated float last_logits = 3; // optional in scaffold
  string error = 4;
}

// Batch prefill: supply multiple sequences; optionally return last logits for each
message BatchPrefillRequest {
  string session_id = 1;
  repeated string seq_ids = 2;
  repeated Tokens tokens_list = 3; // aligned with seq_ids
  repeated uint32 start_pos_list = 4;
  bool return_last_logits = 5;
}
message Tokens {
  repeated uint32 tokens = 1;
}
message BatchPrefillResponse {
  bool ok = 1;
  repeated uint32 consumed_list = 2;
  repeated FloatList last_logits_list = 3; // only present if requested
  string error = 4;
}
message FloatList {
  repeated float values = 1;
}

message SamplingParams {
  float temperature = 1;
  uint32 top_k = 2;
  float top_p = 3;
  float repetition_penalty = 4;
  float frequency_penalty = 5;
  uint64 seed = 6;
}

message DecodeRequest {
  string session_id = 1;
  string seq_id = 2;
  uint32 token = 3; // last token
  uint32 pos = 4;   // position of last token
  bool sample_in_worker = 5;
  SamplingParams sampling = 6;
}
message DecodeResponse {
  bool ok = 1;
  repeated float logits = 2; // if sample_in_worker=false
  uint32 next_token = 3;     // if sample_in_worker=true
  string finish_reason = 4;
  string error = 5;
}

// Batch decode: single-step decode for many sequences
message BatchDecodeRequest {
  string session_id = 1;
  repeated string seq_ids = 2;
  repeated uint32 last_tokens = 3; // last token per seq
  repeated uint32 pos_list = 4;    // position per seq
  bool sample_in_worker = 5;
  SamplingParams sampling = 6;
}
message BatchDecodeResponse {
  bool ok = 1;
  repeated FloatList logits_list = 2; // when sample_in_worker=false
  repeated uint32 next_tokens = 3;    // when sample_in_worker=true
  string error = 4;
}

message ReleaseSequenceRequest {
  string session_id = 1;
  string seq_id = 2;
}
message ReleaseSequenceResponse {
  bool ok = 1;
  string error = 2;
}
